window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "tools", "modulename": "tools", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "tools.globals", "modulename": "tools.globals", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "tools.globals.GlobalVariables", "modulename": "tools.globals", "qualname": "GlobalVariables", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "tools.globals.GlobalVariables.n_channels", "modulename": "tools.globals", "qualname": "GlobalVariables.n_channels", "kind": "variable", "doc": "<p></p>\n", "default_value": "None"}, {"fullname": "tools.globals.GlobalVariables.dets_measured", "modulename": "tools.globals", "qualname": "GlobalVariables.dets_measured", "kind": "variable", "doc": "<p></p>\n", "default_value": "None"}, {"fullname": "tools.globals.GlobalVariables.det_simulated", "modulename": "tools.globals", "qualname": "GlobalVariables.det_simulated", "kind": "variable", "doc": "<p></p>\n", "default_value": "None"}, {"fullname": "tools.globals.GlobalVariables.all_detectors", "modulename": "tools.globals", "qualname": "GlobalVariables.all_detectors", "kind": "variable", "doc": "<p></p>\n", "default_value": "None"}, {"fullname": "tools.globals.GlobalVariables.all_isotopes", "modulename": "tools.globals", "qualname": "GlobalVariables.all_isotopes", "kind": "variable", "doc": "<p></p>\n", "default_value": "None"}, {"fullname": "tools.globals.GlobalVariables.std_calib", "modulename": "tools.globals", "qualname": "GlobalVariables.std_calib", "kind": "variable", "doc": "<p></p>\n", "default_value": "None"}, {"fullname": "tools.globals.GlobalVariables.isotopes_tr", "modulename": "tools.globals", "qualname": "GlobalVariables.isotopes_tr", "kind": "variable", "doc": "<p></p>\n", "default_value": "None"}, {"fullname": "tools.globals.GlobalVariables.dets_tr", "modulename": "tools.globals", "qualname": "GlobalVariables.dets_tr", "kind": "variable", "doc": "<p></p>\n", "default_value": "None"}, {"fullname": "tools.globals.GlobalVariables.min_channel_tr", "modulename": "tools.globals", "qualname": "GlobalVariables.min_channel_tr", "kind": "variable", "doc": "<p></p>\n", "default_value": "None"}, {"fullname": "tools.globals.GlobalVariables.min_scores_norm", "modulename": "tools.globals", "qualname": "GlobalVariables.min_scores_norm", "kind": "variable", "doc": "<p></p>\n", "default_value": "None"}, {"fullname": "tools.globals.GlobalVariables.loadings_tr", "modulename": "tools.globals", "qualname": "GlobalVariables.loadings_tr", "kind": "variable", "doc": "<p></p>\n", "default_value": "None"}, {"fullname": "tools.plotting", "modulename": "tools.plotting", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "tools.plotting.saveplot", "modulename": "tools.plotting", "qualname": "saveplot", "kind": "function", "doc": "<p>Saves open matplotlib figure in directory dir_saveplot.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>save_plot</strong>:  True if plot should be saved to folder, False if plot is displayed.</li>\n<li><strong>name</strong>:  includes information on isotope and (optionally) detector, e.g. 'Am241_right'</li>\n<li><strong>title</strong>:  title of the plot</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">save_plot</span><span class=\"p\">:</span> <span class=\"nb\">bool</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">title</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.plotting.get_color_list", "modulename": "tools.plotting", "qualname": "get_color_list", "kind": "function", "doc": "<p>Counts n_iso, the number of different (unique) isotopes in labels.\nBuilds dictionary that assigns each isotope to a color and applies this mapping to labels.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>labels</strong>:  list of labels, does not have to be unique (can be a flat or nested list)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>color_list: list of color (same length as labels), assigning each label to a color.\n          color_dict: dictionary where each (unique) isotope is assigned one color</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">labels</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">,</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tools.plotting.plot_original_and_rebinned_example_spectrum", "modulename": "tools.plotting", "qualname": "plot_original_and_rebinned_example_spectrum", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span>, </span><span class=\"param\"><span class=\"n\">data_ori</span>, </span><span class=\"param\"><span class=\"n\">data_rebinned</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.plotting.plot_mean_spectra_by_isotope_and_detector", "modulename": "tools.plotting", "qualname": "plot_mean_spectra_by_isotope_and_detector", "kind": "function", "doc": "<p>Calculates mean spectra of all isotopes given in names_list, for each detector individually.\nTwo subplots per isotope: 1. original mean spectra (with bg), 2. normalized mean spectra (bg subtracted).\nThe cosine similarity (measure for similarity between spectra) between the means of different detectors is\ncalculated and displayed in right subplot.\nOnly works for single-label spectra or spectra containing one isotope + background.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>iso_list</strong>:  list of isotopes to be shown, e.g. ['Am241', 'Co60', 'Ir192']</li>\n<li><strong>zoom_in</strong>:  Option to zoom into the lower end of the spectra</li>\n<li><strong>save_plots</strong>:  Option to save the plots to folder.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">iso_list</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">zoom_in</span><span class=\"p\">:</span> <span class=\"nb\">bool</span>, </span><span class=\"param\"><span class=\"n\">save_plots</span><span class=\"p\">:</span> <span class=\"nb\">bool</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.plotting.plot_example_spectra_by_isotopes", "modulename": "tools.plotting", "qualname": "plot_example_spectra_by_isotopes", "kind": "function", "doc": "<p>Plots multiple example spectra (one plot per isotope).\nOnly works for single-label spectra or spectra containing one isotope + background.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>iso_list</strong>:  list of isotopes to be shown, e.g. ['Am241', 'Co60', 'Ir192']</li>\n<li><strong>n_spectra</strong>:  'all' or number of maximum spectra plotted</li>\n<li><strong>save_plot</strong>:  Option to save plot to folder</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">iso_list</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">n_spectra</span>, </span><span class=\"param\"><span class=\"n\">save_plot</span><span class=\"p\">:</span> <span class=\"nb\">bool</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.plotting.plot_cos_sim_matrix_means", "modulename": "tools.plotting", "qualname": "plot_cos_sim_matrix_means", "kind": "function", "doc": "<p>Visualizes the cosine similarity as triangular matrix between all isotope spectra means (detectors separately).\nOrange-rimmed: means of same isotope, different detector, that are not similar enough (cos_sim &lt; threshold)\nRed-rimmed: means of different isotopes that are too similar (cos_sim &gt;= threshold)</p>\n\n<p>Only works for single-label spectra or spectra containing one isotope + background.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>cosine_similarity_matrix</strong>:  cosine similarity matrix between mean spectra of all isotopes and detectors\n(only lower triangle)</li>\n<li><strong>names</strong>:  list of xticklabels</li>\n<li><strong>threshold</strong>:  threshold for cosine similarity (minimum value for means of same isotope,\nmaximum value for means of different isotopes)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">cosine_similarity_matrix</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">names</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.plotting.plot_loadings_subplots", "modulename": "tools.plotting", "qualname": "plot_loadings_subplots", "kind": "function", "doc": "<p>Visualize the loadings (transformation matrix from spectral into latent space, consists of stacked mean spectra).\nEach mean spectrum of an isotope is plotted in a subplot. In addition, the part of the spectrum considered in model\ninference (only channels &gt; min_channel_tr) is highlighted in red.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>save_plot</strong>:  Option to save the plot.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">save_plot</span><span class=\"p\">:</span> <span class=\"nb\">bool</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.plotting.plot_confusion_matrix", "modulename": "tools.plotting", "qualname": "plot_confusion_matrix", "kind": "function", "doc": "<p>Plots the classification results as confusion matrix (predicted vs. true labels) using seaborn.\nThis reveals which labels were confused in model inference.\nSquares are framed in different colors according to correctness and completeness of the classification:</p>\n\n<ul>\n<li>green frame: complete &amp; correct classification (for single-label and multi-label)</li>\n<li>golden frame: incomplete, correct classification (only for multi-label)</li>\n<li>orange frame: complete, partially incorrect classification (only for multi-label)</li>\n<li>red frame: incomplete, partially incorrect classification (for single-label and multi-label)</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data_te</strong>:  test dataset (list of dictionaries with each dict containing one spectrum and metadata)</li>\n<li><strong>class_type</strong>:  can be 'single-label' (use only dominant/first label for each spectrum) or\n'multi-label' (use all labels)</li>\n<li><strong>save_plot</strong>:  option to save the plot</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data_te</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">class_type</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">save_plot</span><span class=\"p\">:</span> <span class=\"nb\">bool</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.plotting.plot_misclassified_spectra", "modulename": "tools.plotting", "qualname": "plot_misclassified_spectra", "kind": "function", "doc": "<p>Plots three misclassified spectra, each in one line, in two subplots.\nLeft side: In addition to the original spectrum, the mean spectrum of the correct and predicted label\nare plotted (in green and red) and the scores of the correct and predicted label are printed.\nRight side: In addition to the original spectrum, the denoised spectrum is plotted and\ntheir cosine similarity is calculated.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data_te</strong>:  test dataset (list of dictionaries with each dict containing one spectrum and metadata)</li>\n<li><strong>class_type</strong>:  can be 'single-label' (use only dominant/first label for each spectrum) or\n'multi-label' (use all labels)</li>\n<li><strong>save_plot</strong>:  option to save the plot</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data_te</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">class_type</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">save_plot</span><span class=\"p\">:</span> <span class=\"nb\">bool</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.plotting.plot_denoised_spectrum_example", "modulename": "tools.plotting", "qualname": "plot_denoised_spectrum_example", "kind": "function", "doc": "<p>The original and denoised spectrum are plotted for a random example spectrum and their cosine similarity is printed.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data</strong>:  test dataset (list of dictionaries with each dict containing one spectrum and metadata)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.plotting.plot_misclassification_statistics", "modulename": "tools.plotting", "qualname": "plot_misclassification_statistics", "kind": "function", "doc": "<p>Plots histograms of correct (green) and wrong (red) classifications versus different quantities:</p>\n\n<ul>\n<li>explained variance ratio (measure for the explained variance between original &amp; denoised spectrum)</li>\n<li>cosine similarity (measure for the similarity between original &amp; denoised spectrum)</li>\n<li>integral of the spectrum (number of counts), e.g. to reveal if spectra with too few counts are more likely to be misclassified</li>\n</ul>\n\n<p>In addition, a threshold can be adjusted for each subplot. It can serve as a decision boundary in a measurement and\nclassification routine, deciding whether to trust a prediction or not. They can be altered below.</p>\n\n<p>As an example, if the accuracy improves significantly when only predictions with <code>cosine similarity &gt; 0.85</code> are considered,\nthis rule can be applied in the measurement routine.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data_te</strong>:  test dataset (list of dictionaries with each dict containing one spectrum and metadata)</li>\n<li><strong>class_type</strong>:  can be 'single-label' (use only dominant/first label for each spectrum) or\n'multi-label' (use all labels)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data_te</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">class_type</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.plotting.plot_scores_scatter_matrix", "modulename": "tools.plotting", "qualname": "plot_scores_scatter_matrix", "kind": "function", "doc": "<p>Plots n-dimensional scores as scatter matrix, in each subplot opposing two dimensions / principal components.\nEach training spectrum is displayed as scatter point, colored by its true label.\nTest data are framed in black and colored by their predicted label.\nOptionally, only misclassified test data can be displayed (for only_errs = True).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data_tr</strong>:   training dataset (list of dictionaries with each dict containing one spectrum and metadata)</li>\n<li><strong>data_te</strong>:  test dataset (list of dictionaries with each dict containing one spectrum and metadata)</li>\n<li><strong>class_type</strong>:  can be 'single-label' (use only dominant/first label for each spectrum) or\n'multi-label' (use all labels)</li>\n<li><strong>n_dim_max: maximum number of dimension to be plotted. Default</strong>:  n_dim = 6</li>\n<li><strong>only_errs: option to plot only misclassified test data. Default</strong>:  only_errs = True</li>\n<li><strong>save_plot</strong>:  option to save the plot</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data_tr</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">data_te</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">class_type</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">n_dim_max</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">only_errs</span><span class=\"p\">:</span> <span class=\"nb\">bool</span>,</span><span class=\"param\">\t<span class=\"n\">save_plot</span><span class=\"p\">:</span> <span class=\"nb\">bool</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.plotting.plot_mean_scores_barplot", "modulename": "tools.plotting", "qualname": "plot_mean_scores_barplot", "kind": "function", "doc": "<p>Plots the mean of the predicted scores of each isotope as bar plot (x axes: isotopes_tr).\nFor multi-label data containing more than one isotope are ignored, only the first label is taken into account.\nOnly single-label data (not containing background, e.g. simulated spectra) or the combination of one isotope + background are considered.</p>\n\n<p>For single-label classification of spectral data not containing background, this should lead to distinct bars,\neach isotope having values close to 1 for its corresponding isotope axis in latent space.</p>\n\n<p>Reveals if the dimensionality reduction succeeds to map single-label spectra mainly to the correct isotope axis\nin latent space. This helps to identify which isotopes can be clearly distinguished and which may be mistaken.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data_te</strong>:  test dataset (list of dictionaries with each dict containing one spectrum and metadata)</li>\n<li><strong>class_type</strong>:  classification type (can be 'single-label' or 'multi-label')</li>\n<li><strong>save_plot</strong>:  option to save the plot</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data_te</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">class_type</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">save_plot</span><span class=\"p\">:</span> <span class=\"nb\">bool</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.plotting.identify_misclassifications", "modulename": "tools.plotting", "qualname": "identify_misclassifications", "kind": "function", "doc": "<p>Divides test data into datasets with correct / incorrect predictions.\nFor class_type = 'single-label', only the first label is considered and background is ignored in labels containing\none isotope + background.\nFor class_type = 'multi-label', all labels are considered and any difference between true and predicted\nlabels is counted as error.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data_te</strong>:  test dataset (list of dictionaries with each dict containing one spectrum and metadata)</li>\n<li><strong>class_type</strong>:  can be 'single-label' (use only dominant/first label for each spectrum) or\n'multi-label' (use all labels)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>data_corr: subset of data_te with correct predictions,\n          data_err: subset of data_te with incorrect predictions</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data_te</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">class_type</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">],</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tools.plotting.plot_outlier_confusion", "modulename": "tools.plotting", "qualname": "plot_outlier_confusion", "kind": "function", "doc": "<p>Plot a confusion matrix to compare actual vs predicted outlier labels.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>test_targets (array-like): True labels of test data (0 for known, 1 for unknown).</li>\n<li>prediction (array-like): Predicted labels from the model (0 for known, 1 for unknown).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">test_targets</span>, </span><span class=\"param\"><span class=\"n\">prediction</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.plotting.plot_feature_importance", "modulename": "tools.plotting", "qualname": "plot_feature_importance", "kind": "function", "doc": "<p>Visualize feature importance using a scatter plot.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>feature_names (list of str): Names of the features used in the model.</li>\n<li>y (array-like): Importance scores for each feature.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">feature_names</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.plotting.plot_fitted_sigmoid", "modulename": "tools.plotting", "qualname": "plot_fitted_sigmoid", "kind": "function", "doc": "<p>Plot the data points and fitted sigmoid curve for logistic regression on cosine similarity.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>x_data (array-like): X-axis data points (cosine similarity scores).</li>\n<li>y_data (array-like): Y-axis data points (outlier labels).</li>\n<li>x_fit (array-like): X values for the fitted sigmoid curve.</li>\n<li>y_fit (array-like): Y values for the fitted sigmoid curve.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x_data</span>, </span><span class=\"param\"><span class=\"n\">y_data</span>, </span><span class=\"param\"><span class=\"n\">x_fit</span>, </span><span class=\"param\"><span class=\"n\">y_fit</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.plotting.plot_metrics_vs_threshold", "modulename": "tools.plotting", "qualname": "plot_metrics_vs_threshold", "kind": "function", "doc": "<p>Plot accuracy, precision, and recall scores as a function of cosine similarity threshold.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>cuts (array-like): Threshold values for cosine similarity.</li>\n<li>accuracies (array-like): Accuracy scores for each threshold.</li>\n<li>precisions (array-like): Precision scores for each threshold.</li>\n<li>recalls (array-like): Recall scores for each threshold.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">thresholds</span>, </span><span class=\"param\"><span class=\"n\">accuracies</span>, </span><span class=\"param\"><span class=\"n\">precisions</span>, </span><span class=\"param\"><span class=\"n\">recalls</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.tools_model", "modulename": "tools.tools_model", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "tools.tools_model.train_dim_model", "modulename": "tools.tools_model", "qualname": "train_dim_model", "kind": "function", "doc": "<p>Trains a model for dimensionality reduction.\nThe model is a transformation matrix (loadings), a np.ndarray of shape n_isotopes x n_channels.\nIt consists of stacked mean spectra of isotopes_tr, only from detectors specified in dets_tr.</p>\n\n<p>You should use only single-label spectra for training (e.g. pure isotope spectra without background).\nHence, if your measured spectra from dets_measured contain background, you should choose dets_tr = ['simulated+bg'].</p>\n\n<p>The loadings can be saved to dir_trained_models and loaded for application in spectrum analysis.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data_tr</strong>:  training dataset (list of dictionaries with each dict containing one spectrum)</li>\n<li><strong>save_results</strong>:  option to save the results to dir_trained_models</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data_tr</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">save_results</span><span class=\"p\">:</span> <span class=\"nb\">bool</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.tools_model.transform_spectra", "modulename": "tools.tools_model", "qualname": "transform_spectra", "kind": "function", "doc": "<p>Calculates non-negative scores for all spectra by fitting it with non-negative-least-squares fit\nto the loadings matrix. This corresponds to a dimensionality reduction: Spectra of shape n_measurements x n_channels\nare converted to scores of shape n_measurements x n_isotopes_tr. Hence, in latent space, each dimension\ncorresponds to one isotope.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data</strong>:  spectral data (list of dictionaries with each dict containing one spectrum)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>spectral data with additional properties 'scores' (not normalized) and 'scores_norm' (normalized)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tools.tools_model.calculate_explained_variance", "modulename": "tools.tools_model", "qualname": "calculate_explained_variance", "kind": "function", "doc": "<p>Calculates the explained variance ratio between original and denoised spectrum or spectra.\nChannels below min_channel_tr are neglected.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>original</strong>:  original spectrum or spectra</li>\n<li><strong>denoised</strong>:  denoised spectrum or spectra</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>explained variance ratio between original and denoised spectrum or spectra, between 0 and 1.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">original</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">denoised</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "tools.tools_model.denoise_spectra", "modulename": "tools.tools_model", "qualname": "denoise_spectra", "kind": "function", "doc": "<p>Denoises spectra by transforming the scores back from latent space to spectral space.\nIn this step, noise will be lost.</p>\n\n<p>Any spectrum with n_channels can be an argument but only spectra of isotopes in isotopes_tr will be denoised correctly.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data</strong>:  spectral data (list of dictionaries with each dict containing one spectrum)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>data: spectral data with additional property 'denoised'\n           explained_variance: explained variance ratio (value between 0 and 1)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">],</span> <span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tools.tools_model.apply_dim_model", "modulename": "tools.tools_model", "qualname": "apply_dim_model", "kind": "function", "doc": "<p>Applies the dimensionality reduction model to spectral data by transforming spectra into latent\nspace (scores) and back (denoised spectra).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data</strong>:  spectral data (list of dictionaries with each dict containing one spectrum and metadata)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>spectral data with additional properties 'scores', 'scores_norm' and 'denoised'</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tools.tools_model.create_prediction_dict", "modulename": "tools.tools_model", "qualname": "create_prediction_dict", "kind": "function", "doc": "<p>Creates dictionary in the form {isotope: score} between isotopes_tr and scores, sorted by descending scores.\nBackground is moved to the end of the dictionary.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data_te</strong>:  test dataset (list of dictionaries with each dict containing one spectrum and metadata)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>data_te: test dataset with the additional property 'labels_pred_dict'</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data_te</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tools.tools_model.print_multi_label_accuracies", "modulename": "tools.tools_model", "qualname": "print_multi_label_accuracies", "kind": "function", "doc": "<p>Calculates the accuracies of multi-label predictions (compared to true labels).</p>\n\n<ol>\n<li>Mean accuracy: One value reflecting the overall accuracy. Correct predictions contribute with their\npositive score, incorrect predictions with their negative score. In addition, missing (true) labels are\npenalized by subtracting their share from the scores.</li>\n</ol>\n\n<ol start=\"2\">\n<li>Individual accuracies:\na) perfect predictions: predicted labels = true labels\nb) incomplete, but only-correct predictions: predicted labels &lt; true labels\nc) complete, but partially wrong predictions: predicted labels &gt; true labels\nd) incomplete and partially wrong predictions: predicted labels include wrong labels and some true labels are missing.</li>\n</ol>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data_te</strong>:  _description_</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data_te</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.tools_model.print_single_label_accuracy", "modulename": "tools.tools_model", "qualname": "print_single_label_accuracy", "kind": "function", "doc": "<p>Calculates and prints the accuracy of the single-label predictions.\nThis means that for predicted labels, only the isotope with the highest score counts.\nFor true labels (where we have no information on the contribution), the first isotope counts,\nbut isotopes are preferred to background.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data_te</strong>:  test dataset (list of dictionaries with each dict containing one spectrum and metadata)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data_te</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.tools_model.classify_from_scores", "modulename": "tools.tools_model", "qualname": "classify_from_scores", "kind": "function", "doc": "<p>Uses the scores to predict which isotopes are found in each test spectrum.\nFirst, a dictionary is created in the form {isotope: score}, ordered by descending scores.\nSecond, the accuracy of the prediction over the whole test dataset is calculated.\nOptions:</p>\n\n<ul>\n<li>single-label classification: compare only first true/predicted label (for single-label spectra)</li>\n<li>multi-label classification: compare all true/predicted labels (for multi-label spectra)</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data_te</strong>:  test dataset (list of dictionaries with each dict containing one spectrum and metadata)</li>\n<li><strong>class_type</strong>:  can be 'single-label' or 'multi-label'</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>test dataset with additional property ['labels_pred_dict'] (dictionary of predicted\n          isotope-score pairs)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data_te</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">class_type</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tools.tools_outlier", "modulename": "tools.tools_outlier", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "tools.tools_outlier.enrich_dicts_with_information", "modulename": "tools.tools_outlier", "qualname": "enrich_dicts_with_information", "kind": "function", "doc": "<p>based on available information of each spectra, additional information is calculated and stored.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>list_dict</strong>:  list of dictonaries containging spectra and meta data</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>same dicts with additional information</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">list_dict</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.tools_outlier.split_spectra_one_vs_all", "modulename": "tools.tools_outlier", "qualname": "split_spectra_one_vs_all", "kind": "function", "doc": "<p>Split data by label into two datasets: one isotope and all others.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data</strong>:  spectral data</li>\n<li><strong>isotopes</strong>:  list of all isotopes found in data as labels</li>\n<li><strong>excluded_isotope</strong>:  _description_</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>data_one: data of excluded_isotope\n          isotope_one: name of excluded_isotope (as array)\n          data_other: data from all isotopes but excluded_isotope\n          isotopes_other: names of all isotopes but excluded_isotopes (as array)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">isotopes</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">excluded_isotope</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.tools_outlier.simulate_outlier", "modulename": "tools.tools_outlier", "qualname": "simulate_outlier", "kind": "function", "doc": "<p>Trains a dimensionality reduction model with all outliers except for isotope_outlier.\nThen, the model is applied to all known data, but also to unknown data (of isotope_outlier).\nWe record the information how unknown spectra appears in latent space\nand construct two arrays with information on the known and unknown isotopes.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>isotope_outlier</strong>:  name of isotope that should be excluded from training</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>np.array(), np.array()</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">isotope_outlier</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.tools_outlier.check_column_names_match", "modulename": "tools.tools_outlier", "qualname": "check_column_names_match", "kind": "function", "doc": "<p>Validates that the number of rows in <code>x_combined</code> and <code>labels_combined</code> match and that the combined\narray has the same number of columns as specified in <code>column_names</code>.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>x_combined : np.ndarray\n    The first array to be combined, typically containing feature data.\nlabels_combined : np.ndarray\n    The second array to be combined, typically containing labels or additional data columns.\ncolumn_names : list of str\n    A list of column names that should match the total number of columns in the horizontally stacked array.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If <code>x_combined</code> and <code>labels_combined</code> do not have the same number of rows.\nValueError\n    If the combined array has a different number of columns than the length of <code>column_names</code>.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This function horizontally stacks <code>x_combined</code> and <code>labels_combined</code>, then verifies the column count\nagainst <code>column_names</code>. If the count does not match, it raises an error to prompt manual adjustment.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x_combined</span>, </span><span class=\"param\"><span class=\"n\">labels_combined</span>, </span><span class=\"param\"><span class=\"n\">column_names</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.tools_outlier.fit_logistic_regression_for_outlier_feature", "modulename": "tools.tools_outlier", "qualname": "fit_logistic_regression_for_outlier_feature", "kind": "function", "doc": "<p>Fits a logistic regression to separate known and unknown data based on a feature, e.g. the cosine similarity.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df_combined</strong>:  dataframe of known and unknown data</li>\n<li><strong>feature</strong>:  column name in dataframe of the feature to be used to distinguish known and unknown data, e.g. 'cos.sim.'</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>x and y values and fitted logistic regression curve</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df_combined</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>, </span><span class=\"param\"><span class=\"n\">feature</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.tools_outlier.sigmoid", "modulename": "tools.tools_outlier", "qualname": "sigmoid", "kind": "function", "doc": "<p>Sigmoid function definition</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">x0</span>, </span><span class=\"param\"><span class=\"n\">k</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.tools_outlier.SimplePredict", "modulename": "tools.tools_outlier", "qualname": "SimplePredict", "kind": "function", "doc": "<p>Function to compare elements of a 1D numpy array with a threshold (cut).</p>\n\n<p>Parameters:\ndata (numpy.ndarray): 1D numpy array containing numeric data\ncut (float): A threshold value between 0 and 1</p>\n\n<p>Returns:\nnumpy.ndarray: A 1D numpy array where 0 corresponds to values above the cut, and 1 corresponds to values below or equal to the cut.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">cut</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.tools_outlier.set_isotope_outliers", "modulename": "tools.tools_outlier", "qualname": "set_isotope_outliers", "kind": "function", "doc": "<p>Set isotope_outliers to the values of all_isotopes</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>all_isotopes</strong>:  list of all isotopes</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>list of isotopes that should play outlier</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">all_isotopes</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.tools_preprocessing", "modulename": "tools.tools_preprocessing", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "tools.tools_preprocessing.check_folder_structure", "modulename": "tools.tools_preprocessing", "qualname": "check_folder_structure", "kind": "function", "doc": "<p>Ensures that the essential folders for data input (spectral data) and output (plots, trained models) are built (relative paths).</p>\n\n<p>In addition, .txt file that define the isotopes that should be preprocessed are necessary of dir_data. It should contain a list of clear\nisotope names, e.g. Am241, Eu152, multi-class, background (where multi-class stands for spectra that include multiple isotopes at once).</p>\n\n<p>The isotopes defined in the .txt file should be a substring in all spectral data files of this isotope so they can be concatenated\nto one file in concatenate_isotope_datasets().\nExample: The file '20240805_Am241_highcountrates.npy' will be matched to the isotope 'Am241'.</p>\n\n<p>Files of isotopes that are missing in the .txt file will not be preprocessed!\nIf the .txt file is missing, it is generated automatically but still has to be filled in manually.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.tools_preprocessing.clear_preprocessed_data", "modulename": "tools.tools_preprocessing", "qualname": "clear_preprocessed_data", "kind": "function", "doc": "<p>Deletes the content (previously preprocessed data) of the specified paths.\nOtherwise, analysis scripts might unintentionally use old/outdated data.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>paths</strong>:  relative paths to the folders that should be cleared.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">paths</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.tools_preprocessing.read_isotope_list", "modulename": "tools.tools_preprocessing", "qualname": "read_isotope_list", "kind": "function", "doc": "<p>Opens the (manually written) txt-file of the measured/simulated isotopes\nPurpose: users can specify in this txt file which isotopes to include in preprocessing and set filenames.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>list of the isotopes as defined in the txt files in dir_data, e.g. ['Am241', 'Eu152', 'background']</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tools.tools_preprocessing.rebinning", "modulename": "tools.tools_preprocessing", "qualname": "rebinning", "kind": "function", "doc": "<p>Reads spectral data and (original) energy calibrations from folder numpy_raw.\nRebinning: Conversion from channels to energies (using the original energy calibration), then\nconversion from energies back to standardized channels (using the given standard calibration)</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>all_files_list</strong>:  list of all files (Output of create_list_of_spectra_files())</li>\n<li><strong>std_calib: standard (target) energy calibration parameters, e.g. std_calib = {'offset': -10.3, 'slope': 8.1, 'quad'</strong>:  0.001}</li>\n<li><strong>show_plot</strong>:  option to plot an original and rebinned example spectrum vs. the energy channels</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>dictionary with filenames as keys and data (list of dicts) as value where each dict corresponds to one spectrum + metadata.\n      e.g.    {'Am241_1_right':   [{'spectrum': [...], 'labels':[...]}, {'spectrum': ..., 'labels'}],\n              '240805_Ba133_left': [{'spectrum': [...], 'labels':[...]}, {'spectrum': ..., 'labels'}]}</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">all_files_list</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">std_calib</span><span class=\"p\">:</span> <span class=\"n\">Dict</span>,</span><span class=\"param\">\t<span class=\"n\">show_plot</span><span class=\"p\">:</span> <span class=\"nb\">bool</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tools.tools_preprocessing.concatenate_isotope_datasets", "modulename": "tools.tools_preprocessing", "qualname": "concatenate_isotope_datasets", "kind": "function", "doc": "<p>Checks there are multiple datasets per isotope &amp; detector in dict_of_data.\nIf so, they are concatenated. If not, they are passed on.\nExample: 'Co60_1_right' and 'Co60_2_right' are concatenated to 'Co60_right'.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dict_of_data: dictionary in the form {filename</strong>:  data} where data is a list of dictionaries\ne.g.    {'Am241_1_right':   [{'spectrum': [...], 'labels':[...]}, {'spectrum': ..., 'labels'}],\n        '240805_Ba133_left': [{'spectrum': [...], 'labels':[...]}, {'spectrum': ..., 'labels'}]}</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>dictionary in the form {isotope_detector: data} where data is a list of dictionaries\n       e.g.   {'Am241_right': [{'spectrum': [...], 'labels':[...]}, {'spectrum': ..., 'labels'}],\n              'Ba133_left':   [{'spectrum': [...], 'labels':[...]}, {'spectrum': ..., 'labels'}]}</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dict_of_data</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tools.tools_preprocessing.concatenate_detector_datasets", "modulename": "tools.tools_preprocessing", "qualname": "concatenate_detector_datasets", "kind": "function", "doc": "<p>Checks isotope-wise if there are multiple datasets from different detectors.\nConcatenates data of different detectors (e.g. right, left, simulated) to one dataset\nExample: 'Co60_left', 'Co60_right' and 'Co60_sim' are concatenated and saved as 'Co60.npy'</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dict_of_data: dictionary in the form {isotope_detector</strong>:  data} where data is a list of dictionaries\ne.g.   {'Am241_right': [{'spectrum': [...], 'labels':[...]}, {'spectrum': ..., 'labels'}],\n       'Ba133_left':   [{'spectrum': [...], 'labels':[...]}, {'spectrum': ..., 'labels'}]}</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>dictionary in the form {isotope: data} where data is a list of dictionaries\n       e.g.   {'Am241': [{'spectrum': [...], 'labels':[...]}, {'spectrum': ..., 'labels'}],\n              'Ba133':   [{'spectrum': [...], 'labels':[...]}, {'spectrum': ..., 'labels'}]}</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dict_of_data</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tools.tools_preprocessing.limit_spectra_per_isotope", "modulename": "tools.tools_preprocessing", "qualname": "limit_spectra_per_isotope", "kind": "function", "doc": "<p>Limits the number of spactra per isotope to n_max.\nSaves one .npy-file per isotope in directory dir_numpy_ready.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dict_of_data: dictionary in the form {isotope</strong>:  data} where data is a list of dictionaries\ne.g.   {'Am241': [{'spectrum': [...], 'labels':[...]}, {'spectrum': ..., 'labels'}],\n       'Ba133':   [{'spectrum': [...], 'labels':[...]}, {'spectrum': ..., 'labels'}]}</li>\n<li><strong>n_max</strong>:  maximum number of spectra per isotope, defaults to 10000</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dict_of_data</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]]</span>, </span><span class=\"param\"><span class=\"n\">n_max</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">10000</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.tools_preprocessing.calc_cos_sim_matrix_means", "modulename": "tools.tools_preprocessing", "qualname": "calc_cos_sim_matrix_means", "kind": "function", "doc": "<p>Calculates cosine similarity between all mean spectra for all isotopes (different detectors individually).\nResults in symmetric matrix, only the lower left triangle is kept.\nOnly works for single-label spectra or spectra containing one isotope + background.</p>\n\n<p>The result can be passed to plot_cos_sim_matrix for visualization.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>iso_list</strong>:  list of isotopes to be shown, e.g. ['Am241', 'Co60', 'Ir192']</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>cosine similarity matrix between mean spectra of all isotopes and detectors (only lower triangle)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">iso_list</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tools.util", "modulename": "tools.util", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "tools.util.dir_plots", "modulename": "tools.util", "qualname": "dir_plots", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;plots&#x27;"}, {"fullname": "tools.util.dir_trained_models", "modulename": "tools.util", "qualname": "dir_trained_models", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;trained_models&#x27;"}, {"fullname": "tools.util.dir_data", "modulename": "tools.util", "qualname": "dir_data", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;data&#x27;"}, {"fullname": "tools.util.dir_numpy_raw", "modulename": "tools.util", "qualname": "dir_numpy_raw", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;data/1_numpy_raw&#x27;"}, {"fullname": "tools.util.dir_numpy_ready", "modulename": "tools.util", "qualname": "dir_numpy_ready", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;data/2_numpy_ready&#x27;"}, {"fullname": "tools.util.save_list_of_dicts", "modulename": "tools.util", "qualname": "save_list_of_dicts", "kind": "function", "doc": "<p>Saves spectral data (list of dicts) to the specified directory (dir_data_out).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dir_data_out</strong>:  directory where data is saved (relative path)</li>\n<li><strong>data</strong>:  spectral data (list of dicts, each dict contains one spectrum)</li>\n<li><strong>name</strong>:  filename of the saved data</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dir_data_out</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">PathLike</span>, </span><span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.util.load_spectral_data", "modulename": "tools.util", "qualname": "load_spectral_data", "kind": "function", "doc": "<p>Loads all spectra of input directory but only of the specified detector.\nSpecial case: for 'simulated+bg', all simulated data and backgrounds (from measured data) are loaded.\nIf exclude_files is given as a list, those files are not loaded.\nIf include_files is given as a list, only those files are loaded from the directory.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dir_input</strong>:  directory from where data is loaded</li>\n<li><strong>detectors</strong>:  specify from which detectors the data should be.\ne.g. ['left', 'right', 'simulated', 'simulated+bg'] (or subset)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>data_new: all spectral data (list of dictionaries)\n          isotopes_det:</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dir_input</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">PathLike</span>,</span><span class=\"param\">\t<span class=\"n\">detectors</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">],</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tools.util.limit_length_of_dataset", "modulename": "tools.util", "qualname": "limit_length_of_dataset", "kind": "function", "doc": "<p>Option to limit the number of spectra dictionaries in a dataset (e.g. for quick tests).\nIf data is shorter than n_spectra_max, the complete list will be returned</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data_list</strong>:  _list that should be shortened</li>\n<li><strong>n_spectra_max</strong>:  maximum number of elements in the output list</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>shortened list (maximum length: n_spectra_max)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">n_spectra_max</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tools.util.cosine_similarity", "modulename": "tools.util", "qualname": "cosine_similarity", "kind": "function", "doc": "<p>Calculates the cosine similarity between two vectors (two spectra) with mean centering</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>a</strong>:  Spectrum a (list or numpy array)</li>\n<li><strong>b</strong>:  Spectrum b (list or numpy array)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>cosine similarity between a and b</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "tools.util.calc_mean", "modulename": "tools.util", "qualname": "calc_mean", "kind": "function", "doc": "<p>Opens the spectral data of isotope from folder and separates it into training and test set.\nCalculates the mean spectrum and standard deviation of the specified detectors for the training set.\nFor datasets containing both isotope+background and pure background spectra: separates them\nand calculates the means separately.\nIf norm=True, all means are normalized to integral 1 and standard deviations are adapted accordingly.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>isotope</strong>:  isotope of which data are used, without file extension, e.g. 'Am241'</li>\n<li><strong>folder</strong>:  directory where file is stored</li>\n<li><strong>detectors</strong>:  list of detectors from which data are used,\ne.g. ['right', 'left', 'simulated', 'simulated+bg'] (or subset of those)</li>\n<li><strong>norm</strong>:  Option to normalize the returned mean spectra to integral 1</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>mean spectra and standard deviations (length: n_features) of the data found in <folder>/<name>,\n      separated into isotope and pure background.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">isotope</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">folder</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">PathLike</span>,</span><span class=\"param\">\t<span class=\"n\">detectors</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">norm</span><span class=\"p\">:</span> <span class=\"nb\">bool</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.util.count_spectra_per_isotope", "modulename": "tools.util", "qualname": "count_spectra_per_isotope", "kind": "function", "doc": "<p>Counts the number of spectra per isotope (aggregated by labels).\nReturns list of counts</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data</strong>:  spectral data (list of dicts, each dict containing a spectrum, labels and metadata)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tools.util.remove_empty_or_negative_spectra", "modulename": "tools.util", "qualname": "remove_empty_or_negative_spectra", "kind": "function", "doc": "<p>Checks spectral data for empty spectra or negative values.\nEmpty spectra are removed, negative values are replaced with 0.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data</strong>:  spectral data (list of dicts, each dict containing a spectrum, labels and metadata)</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>:  data has to include at least one element.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>spectral data, with empty spectra removed and negative values replaced by 0.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tools.util.check_for_nan_and_inf", "modulename": "tools.util", "qualname": "check_for_nan_and_inf", "kind": "function", "doc": "<p>Checks the value of variable_dict for NaNs and infs.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>variable_dict: dictionary in the form {<variable name></strong>:  <variable data>},\ne.g. {'loadings': loadings_train}</li>\n<li><strong>function_name</strong>:  name of the function where this function was called (for debugging)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">variable_dict</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">function_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tools.util.split_train_test", "modulename": "tools.util", "qualname": "split_train_test", "kind": "function", "doc": "<p>Splits data into a training and a test set. As test size and random state are fixed, this function ensures reproducibility</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>array</strong>:  list or array to be split into training and test set</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>training and test set</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">array</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">],</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tools.util.normalize_spectra", "modulename": "tools.util", "qualname": "normalize_spectra", "kind": "function", "doc": "<p>Normalizes one spectrum or multiple spectra to integral 1. If spectra contains an empty spectrum, an error\nmessage is thrown and the original spectra are returned.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>spectra</strong>:  one or more spectra</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>normalized spectra (integral 1)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">spectra</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();